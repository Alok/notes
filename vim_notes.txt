VIM NOTES
==================
good:
    http://vimcasts.org/
    http://glts.github.io/2013/04/28/vim-normal-mode-grammar

plugins:
    ctags.sourceforge.net 
        export PATH="/usr/local/bin:$PATH"

READ results into cursor position (acme!) - http://stackoverflow.com/a/2960630 
                                            http://superuser.com/a/251959/114842
    :r!foo                 read in stdout from a shell command
    <c-r>=system('foo')
    :r [file]              read in contents of [file]
    <c-r>=&vim_variable    hint: works with tab-complete (wildmenu)
    <c-r>=SomeFunction()
    <c-r>[register_name]   % # : .

FILTER buffer contents through shell command (acme!) - http://stackoverflow.com/a/790218/152142
    In normal mode, ! is an operator (action) like y/d/c. You can do: 
        !!
        {range}!!
        !{motion}{shell cmd} (e.g. !Gls<cr>)
    Instead of :.!date write "date" in a buffer, then (in normal mode): 
        !<space>sh This will pipe the line to the "sh" shell and substitute 
        with the output from the command.

    :{range}! filters a range of lines through a command and replaces those 
    lines with the output.

    examples (normal mode):
        :%!             filters the whole buffer
        !{space}{cmd}   replace the current line with <cmd> stdout
        !{space}sh      run the current line as a shell command
        !Gsort          equivalent to :.,$!sort

REDIRECT messages (all output from all vim commands)
    :redir >> [file]
    :redir @x          redirect to register 'x'
    :redir END
    :let @x = system('ls')  store shell command output to register x

    example: write output from :changes to register 'x'
        :set nomore | redir @x | changes | redir END | set more
    then read into another buffer:
        <c-r>=@x

REGISTERS: http://stackoverflow.com/a/3997110/152142
    "=          expression register
                eg: "=command_or_&variable<cr>p
    ""          unnamed register (always gets written-to)
    ".          the last inserted text
    "_          blackhole register
    "0          contains the last yank
    "1-"9       contain the last 9 deletions
    y"x         yank line to register x
    yy"X        *append* line to register x

    example: replace word with last-yanked text
        ciw<C-r>0

    example (acme!): increment register x and insert its value
        let @x=@x+1 | exe 'norm i' . @x

fundamental:
    capitalizing (shift) performs the "inverse" of the command
    .             repeat the previous command
    :5,42[cmd]    prepend a range to any command

modifiers:
    *,#  search "whole word" under cursor
    f    forward
    t    til

special buffers:
    q:
    q/

substitute (search/replace):
  almost any character (following s) can be used as the delimiter:
    :%s/before/after/g
    :%s@before@after@g
  e-option:
    :%s/foo/bar/ge
                 ^--ignore errors

multi-repeat / global apply:
    :[range]g/{pattern}/[cmd]    apply cmd to lines matching {pattern}
    :[range]g!/{pattern}/[cmd]   inversion (apply to lines NOT matching)

    examples: 
        print all matches of /re/:   http://stackoverflow.com/a/509720/152142
            :g/re/p
        change (substitute) foo to bar only on #comment lines:
            :g/^\s*#/s/foo/bar/g
        delete lines that match foo:
            :g/foo/normal dd
        append all lines matching foo to register a:
            :g/foo/normal "Ay
            :g/foo/y A
        append the result of col('.') to lines 265-292:
            265,292s/$/\=col('.')/
                        ^--- use \= for per-line evaluation

rubydo, pydo, perldo, luado, ...
    reverse lines 1-5
        :1,5luado return line:reverse()
    prepend each line with its length
        :pydo return str(len(line)) + line
    reverse WORDs on current line
        :.perldo $_ = join ' ', reverse split
    insert a random string of 8 characters (A-Z) at the end of every line
        :rubydo $_ += ' ' + (1..8).collect{('A'..'Z').to_a[rand 26]}.join

macros (complex-repeat):
    qx  start recording in register x 
    q   stop recording
    @x  execute the text in register x 
        example (acme!): yank any text, then execute with @"
    @@  replay the most recent macro
    @:  repeat the last command!

window management:
    ctrl-w-[v s o]
    ctrl-w-[c h j k l]
    ctrl-w-[= | _]
    zN<enter>               resize vim height to N (useful for...?)

buffer hopping:
    ctrl-^ :ls

file management (netrw):
    :E     browse directory of current buffer (_not_ the :pwd directory)
    :Vex   browse directory of current buffer in a new split window

OPEN file/uri:
    gx              open url 
    [ctrl-w]gf      open file [in new window]

MOVE through text:
    gg G 0 $ f t ; % 
    ]} ]] ) } 
    e E ge gE    move to end of word
    w W          move to next word

MOVE through changes and jumps:
    g; g,           jump up/down the changes stack
    gi              enter insert-mode at the location of the last insert
    `.              jump to the very last change *in the buffer*
    ctrl-o ctrl-i   jump up/down the jumps stack
    ``              jump to the last jump *in the buffer*

undo:
    :earlier 5m
    :later 30s
    :earlier 1f     go to the last saved state
    :later 1f       go to the newest buffer state

editing:
    i I a A o O J
    c[iaft]["({]
    c/foo 
    ~             toggle case
    ctrl-n        autocomplete WORD
    ctrl-x-l      autocomplete LINE
    ctrl-x-f      autocomplete file path
    ctrl-x-o      OMNIcomplete 

indentation:
    > <      indent
    ==       fix indent

indentation, (insert mode):
    ctrl-t ctrl-d

visual/selection:
    vib vab         b = parentheses block
    viB vi{ vaB     B = brace block
    vababab         repeat to expand selection
    vi}i}i}
    gv              reselect last selection
    gn              select next match (text object, can be composed!)
                    example: /foo<cr>cgnqux<esc>..
                        foo bar      qux bar
                        baz foo  =>  baz qux
                        foobl a      quxbl a
    o               jump to other end of visual selection

COMMAND mode:
    ctrl-d      show table of command (and file/dir/path!) suggestions

buffer info:
    ctrl-g      show file path in status
    g-ctrl-g    show word count, etc

viml / vimscript / plugin development:   http://stevelosh.com/blog/2011/09/writing-vim-plugins/
    normal!     like normal, but ignores mappings the user has set up

debugging vim
    :scriptnames
    :verbose set foo
    :verbose map %
    :set verbose=9      debug autocommands


NEW USER NOTES
==============
https://github.com/google/glaive
https://github.com/google/maktaba

vim is a concept
    - modal editing, atomic edits, edit grammar
    - can be implemented in any editor/IDE
vim is a component
    - can be embedded in other applications/IDEs
vim is _not_ a platform (unlike emacs)

scoping (local variables): 
    let g:foo = 'qux'
    let foo = 'bar'
        - does _not_ overwrite g:foo
        - cannot overwrite v:foo
        - echo g:foo => 'qux'
        - echo foo => 'bar'
    l: is almost never needed, because:
        - 'let foo' will not modify the environment _outside_ of the local function scope

don't bother with cream
don't get windows build from vim.org

vim's "current directory" applies to the entire vim session (the current 
running instance of Vim), regardless of what file (buffer) you are 
currently using. Think of it as your "working directory" for the current 
vim session. 

:make and &makeprg are for processing the current buffer through *any* program.
The name "make" is just a historical misnomer.

"quickfix" is a historical misnomer and it is perfectly acceptable to use
this buffer for any list of annotations received from :make.

Vim refers to text documents as *buffers*. Get used to that. This is a useful
distinction, not just pedantic, because: a new file, which is not saved 
yet, doesn't have a path on the filesystem yet: it may exist only in Vim. Vim 
also has special buffers like the "quick fix" window and the "preview" window.

Vim *in the terminal* is at the mercy of the terminal. Using Vim in the 
terminal makes it obvious the distinctions that perhaps were not so 
important before you started using a text editor in the terminal. Before, 
the distinction between "shell" and "terminal emulator" may have seemed
like noise. But once you start using vim on different systems, the 
quirks of the various terminal and shell implementations are brought into
relief. A terminal sends characters to the shell. Vim, in the context of 
a terminal, accepts the characters sent to it. When you enter ALT-f in
terminal Vim, one terminal may send <foo>f to Vim, another <bar>f.
The state of the terminal in this decade might seem rather frustrating, 
but c'est la vie. Powershell is the only really innovative, 
widely-deployed alternative, and while it's to be commended, it doesn't 
have a terminal-resident editor (and it's terminal is cmd.exe). So if 
using terminal-vim as your *primary* editor is too much trouble, 
just use gvim and forget about it. But that's where we are. VT-100 legacy 
is sitting on top of a massive, massive pile of tools and powershell 
isn't positioned to address.
    discussion to improve Vim terminal behavior: http://stackoverflow.com/a/14642074/152142

sed becomes second nature as a side-effect of normal, prolific Vim usage.
Searching for ^\s.+ becomes an actually desirable thing to reach for, 
because then you can `cgn` the matches. Regex (even if quirky) becomes 
an actually desirable tool. For real, seriously. You won't get that in 
sublime. I had no desire to learn sed, because I always thought "I'll 
just reach for python or ruby or whatever". And yes, you can do that 
in vim too (:py :ruby :lua).

vnoremap, noremap, xnoremap. Q: Why care about selection-mode? A: For snippets plugins.

http://learnvimscriptthehardway.stevelosh.com/
    - gave vim a high-quality, accessible, attractive go-to tutorial
    - now we just need a better brand at vim.org

UNIQUE FEATURES (not counting emacs et al)
==========================================
persistent undo
undo tree / :earlier / :later
