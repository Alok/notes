VIM NOTES
==================
good:
    http://vimcasts.org/

plugins:
    ctags.sourceforge.net 
        export PATH="/usr/local/bin:$PATH"

READ results into cursor position (acme!) - http://stackoverflow.com/a/2960630 
                                            http://superuser.com/a/251959/114842
    :r!foo                 read in stdout from a shell command
    <c-r>=system('foo')
    :r [file]              read in [file] contents of 
    <c-r>=&vim_variable    (doesn't like abbreviated names, but wildmenu works)
    <c-r>=SomeFunction()
    <c-r>%
    <c-r>#
    <c-r>:

REDIRECT messages (all output from all vim commands)
    :redir >> [file]
    :redir @x          redirect to register 'x'
    :redir END
    :let @x = system('ls')  store shell command output to register x

    example: write output from :changes to register 'x'
        :set nomore | redir @x | changes | redir END | set more
    then read into another buffer:
        <c-r>=@x

REGISTERS: http://stackoverflow.com/a/3997110/152142
    "=          expression register
                ex: "=command_or_&variable<cr>p
    ""          unnamed register (always gets written-to)
    "_          blackhole register
    "0          contains the last yank
    "1 .."9     contain the last 9 deletions
    y"x         yank line to register x
    yy"X        *append* line to register x

    example (acme!): increment register x and insert its value
        let @x=@x+1 | exe 'norm i' . @x

fundamental:
    capitalizing (shift) performs the "mirror" of the command
    .             repeat the previous command
    :5,42[cmd]    prepend a range to any command

modifiers:
    *,#  search "whole word" under cursor
    f    forward
    t    til

special buffers:
    q:
    q/

multi-repeat / global apply:
    :[range]g/{pattern}/[cmd]    apply cmd to lines matching {pattern}
    :[range]g!/{pattern}/[cmd]   inversion (apply to lines NOT matching)

    examples: 
        change foo to bar only on comment lines that begin with #:
            :g/^\s*#/s/foo/bar/g
        delete lines that match foo:
            :g/foo/normal dd
        append all lines matching foo to register a:
            :g/foo/normal "Ay

macros (complex-repeat):
    qx  start recording in register x 
    q   stop recording
    @x  execute the text in register x 
        example (acme!): yank any text, then execute with @"
    @@  replay the most recent macro
    @:  repeat the last command!

window splitting:
    ctrl-w-v   ctrl-w-s
    ctrl-w-[c hjkl]
    ctrl-w-[= | _]

buffer hopping:
    ctrl-^ :ls

file management (netrw):
    :E     browse directory of current buffer (_not_ the :pwd directory)

MOVE through text:
    gg G 0 $ f t ; % 
    ]} ]] ) } 
    e E ge gE    move to end of word
    w W          move to next word
    gx           open url 

MOVE through the "change list":
    g; g, :changes

MOVE through the "jump list":
    ctrl-o ctrl-i

editing:
    i I a A o O J
    c[iaft]["({]
    c/foo 
    ~             toggle case
    ctrl-n        autocomplete WORD
    ctrl-x-l      autocomplete LINE
    ctrl-x-o      OMNIcomplete 

indentation (normal/visual mode):
    > <      indent
    ==       fix indent

indentation, (insert mode):
    ctrl-t ctrl-d

selection:
    vib vab      b = parentheses block
    viB vi{ vaB  B = brace block
    gv           reselect last selection

debugging vim
    :scriptnames
    :verbose set &foo
    :verbose map %

