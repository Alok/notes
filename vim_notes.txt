VIM NOTES
==================
good:
    http://vimcasts.org/

plugins:
    ctags.sourceforge.net 
        export PATH="/usr/local/bin:$PATH"

READ results into cursor position (acme!) - http://stackoverflow.com/a/2960630 
                                            http://superuser.com/a/251959/114842
    :r!foo                 read in stdout from a shell command
    <c-r>=system('foo')
    :r [file]              read in contents of [file]
    <c-r>=&vim_variable    hint: works with tab-complete (wildmenu)
    <c-r>=SomeFunction()
    <c-r>[register_name]   %,#,:,...

READ results into command line
    <c-\> e {expr}        read expression into the command line (useful in mappings)

REDIRECT messages (all output from all vim commands)
    :redir >> [file]
    :redir @x          redirect to register 'x'
    :redir END
    :let @x = system('ls')  store shell command output to register x

    example: write output from :changes to register 'x'
        :set nomore | redir @x | changes | redir END | set more
    then read into another buffer:
        <c-r>=@x

REGISTERS: http://stackoverflow.com/a/3997110/152142
    "=          expression register
                ex: "=command_or_&variable<cr>p
    ""          unnamed register (always gets written-to)
    "_          blackhole register
    "0          contains the last yank
    "1 .."9     contain the last 9 deletions
    y"x         yank line to register x
    yy"X        *append* line to register x

    example (acme!): increment register x and insert its value
        let @x=@x+1 | exe 'norm i' . @x

fundamental:
    capitalizing (shift) performs the "mirror" of the command
    .             repeat the previous command
    :5,42[cmd]    prepend a range to any command

modifiers:
    *,#  search "whole word" under cursor
    f    forward
    t    til

special buffers:
    q:
    q/

substitute (search/replace):
  almost any character (following s) can be used as the delimiter:
    :%s/before/after/g
    :%s@before@after@g
  e-option:
    :%s/foo/bar/ge
                 ^--ignore errors

multi-repeat / global apply:
    :[range]g/{pattern}/[cmd]    apply cmd to lines matching {pattern}
    :[range]g!/{pattern}/[cmd]   inversion (apply to lines NOT matching)

    examples: 
        change foo to bar only on comment lines that begin with #:
            :g/^\s*#/s/foo/bar/g
        delete lines that match foo:
            :g/foo/normal dd
        append all lines matching foo to register a:
            :g/foo/normal "Ay

macros (complex-repeat):
    qx  start recording in register x 
    q   stop recording
    @x  execute the text in register x 
        example (acme!): yank any text, then execute with @"
    @@  replay the most recent macro
    @:  repeat the last command!

window management:
    ctrl-w-[v s o]
    ctrl-w-[c h j k l]
    ctrl-w-[= | _]
    zN<enter>               resize vim height to N (useful for...?)

buffer hopping:
    ctrl-^ :ls

file management (netrw):
    :E     browse directory of current buffer (_not_ the :pwd directory)
    :Vex   browse directory of current buffer in a new split window

OPEN file/uri:
    gx              open url 
    [ctrl-w]gf      open file [in new window]

MOVE through text:
    gg G 0 $ f t ; % 
    ]} ]] ) } 
    e E ge gE    move to end of word
    w W          move to next word

MOVE through changes and jumps:
    g; g,           jump up/down the changes stack
    `.              jump to the very last change
    ctrl-o ctrl-i   jump up/down the jumps stack
    ``              go to the last jump

undo:
    :earlier 5m
    :later 30s

editing:
    i I a A o O J
    c[iaft]["({]
    c/foo 
    ~             toggle case
    ctrl-n        autocomplete WORD
    ctrl-x-l      autocomplete LINE
    ctrl-x-o      OMNIcomplete 

indentation (normal/visual mode):
    > <      indent
    ==       fix indent

indentation, (insert mode):
    ctrl-t ctrl-d

selection:
    vib vab      b = parentheses block
    viB vi{ vaB  B = brace block
    gv           reselect last selection

buffer info:
    ctrl-g      show file path in status
    g-ctrl-g    show word count, etc

debugging vim
    :scriptnames
    :verbose set foo
    :verbose map %

