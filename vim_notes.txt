VIM NOTES
==================
good:
    http://vimcasts.org/

plugins:
    ctags.sourceforge.net 
        export PATH="/usr/local/bin:$PATH"

READ results into cursor position (acme!) - http://stackoverflow.com/a/2960630 
                                            http://superuser.com/a/251959/114842
    :r!foo                 read in stdout from a shell command
    <c-r>=system('foo')
    :r [file]              read in contents of [file]
    <c-r>=&vim_variable    hint: works with tab-complete (wildmenu)
    <c-r>=SomeFunction()
    <c-r>[register_name]   % # : .

FILTER buffer contents through shell command (acme!) - http://stackoverflow.com/a/790218/152142
    In normal mode, ! is an operator (action) like y/d/c. You can do: 
        !!
        {range}!!
        !{motion}{shell cmd} (e.g. !Gls<cr>)
    Instead of :.!date write "date" in a buffer, then (in normal mode): 
        !<space>sh This will pipe the line to the "sh" shell and substitute 
        with the output from the command.

    :{range}! filters a range of lines through a command and replaces those 
    lines with the output.

    examples (normal mode):
        :%!             filters the whole buffer
        !{space}{cmd}   replace the current line with <cmd> stdout
        !{space}sh      run the current line as a shell command
        !Gsort          equivalent to :.,$!sort

REDIRECT messages (all output from all vim commands)
    :redir >> [file]
    :redir @x          redirect to register 'x'
    :redir END
    :let @x = system('ls')  store shell command output to register x

    example: write output from :changes to register 'x'
        :set nomore | redir @x | changes | redir END | set more
    then read into another buffer:
        <c-r>=@x

REGISTERS: http://stackoverflow.com/a/3997110/152142
    "=          expression register
                eg: "=command_or_&variable<cr>p
    ""          unnamed register (always gets written-to)
    ".          the last inserted text
    "_          blackhole register
    "0          contains the last yank
    "1-"9       contain the last 9 deletions
    y"x         yank line to register x
    yy"X        *append* line to register x

    example: replace word with last-yanked text
        ciw<C-r>0

    example (acme!): increment register x and insert its value
        let @x=@x+1 | exe 'norm i' . @x

fundamental:
    capitalizing (shift) performs the "inverse" of the command
    .             repeat the previous command
    :5,42[cmd]    prepend a range to any command

modifiers:
    *,#  search "whole word" under cursor
    f    forward
    t    til

special buffers:
    q:
    q/

substitute (search/replace):
  almost any character (following s) can be used as the delimiter:
    :%s/before/after/g
    :%s@before@after@g
  e-option:
    :%s/foo/bar/ge
                 ^--ignore errors

multi-repeat / global apply:
    :[range]g/{pattern}/[cmd]    apply cmd to lines matching {pattern}
    :[range]g!/{pattern}/[cmd]   inversion (apply to lines NOT matching)

    examples: 
        change foo to bar only on comment lines that begin with #:
            :g/^\s*#/s/foo/bar/g
        delete lines that match foo:
            :g/foo/normal dd
        append all lines matching foo to register a:
            :g/foo/normal "Ay
            :g/foo/y A
        perform substitution on lines matching foo:
            :g/foo/s/aime/adore

macros (complex-repeat):
    qx  start recording in register x 
    q   stop recording
    @x  execute the text in register x 
        example (acme!): yank any text, then execute with @"
    @@  replay the most recent macro
    @:  repeat the last command!

window management:
    ctrl-w-[v s o]
    ctrl-w-[c h j k l]
    ctrl-w-[= | _]
    zN<enter>               resize vim height to N (useful for...?)

buffer hopping:
    ctrl-^ :ls

file management (netrw):
    :E     browse directory of current buffer (_not_ the :pwd directory)
    :Vex   browse directory of current buffer in a new split window

OPEN file/uri:
    gx              open url 
    [ctrl-w]gf      open file [in new window]

MOVE through text:
    gg G 0 $ f t ; % 
    ]} ]] ) } 
    e E ge gE    move to end of word
    w W          move to next word

MOVE through changes and jumps:
    g; g,           jump up/down the changes stack
    `.              jump to the very last change *in the buffer*
    ctrl-o ctrl-i   jump up/down the jumps stack
    ``              jump to the last jump *in the buffer*

undo:
    :earlier 5m
    :later 30s

editing:
    i I a A o O J
    c[iaft]["({]
    c/foo 
    ~             toggle case
    ctrl-n        autocomplete WORD
    ctrl-x-l      autocomplete LINE
    ctrl-x-f      autocomplete file path
    ctrl-x-o      OMNIcomplete 

indentation:
    > <      indent
    ==       fix indent

indentation, (insert mode):
    ctrl-t ctrl-d

visual/selection:
    vib vab         b = parentheses block
    viB vi{ vaB     B = brace block
    vababab         repeat to expand selection
    vi}i}i}
    gv              reselect last selection
    gn              select next match (text object, can be composed!)
                    example: /foo<cr>cgnqux<esc>..
                        foo bar      qux bar
                        baz foo  =>  baz qux
                        foobl a      quxbl a
    o               jump to other end of visual selection

COMMAND mode:
    ctrl-d      show table of command (and file/dir/path!) suggestions

buffer info:
    ctrl-g      show file path in status
    g-ctrl-g    show word count, etc

viml / vimscript / plugin development:   http://stevelosh.com/blog/2011/09/writing-vim-plugins/
    normal!     like normal, but ignores mappings the user has set up

debugging vim
    :scriptnames
    :verbose set foo
    :verbose map %
    :set verbose=9      debug autocommands

