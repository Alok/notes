todo:
    http://www.blaenkdenum.com/notes/clojure/
    http://yogthos.github.io/ClojureDistilled.html
    "Typed Clojure in Practice": https://www.youtube.com/watch?v=a0gT0syAXsY

tutorial
    http://www.youtube.com/user/Misophistful/videos

book:
    http://clojure-cookbook.com/

AMAZING
    http://himera.herokuapp.com/synonym.html
    http://cjohansen.no/clojure-to-die-for

http://clojure.org/cheatsheet

amazing book/tutorial:
    http://www.braveclojure.com/

web app:
    http://blog.josephwilk.net/clojure/building-clojure-services-at-scale.html
    https://github.com/jalehman/react-tutorial-om
    static site generation: http://cjohansen.no/building-static-sites-in-clojure-with-stasis

datomic discussion and video link:
    http://www.reddit.com/r/Clojure/comments/1t6h2v/datomicjunk_a_bunch_of_datomic_utility_functions/

Solving the Expression Problem with Clojure 1.2
    http://www.ibm.com/developerworks/java/library/j-clojure-protocols/index.html#datatypes

macros: http://aphyr.com/posts/305-clojure-from-the-ground-up-macros
    - very good series on clojure

quick start screencast (eclipse, ring)
    http://www.youtube.com/watch?v=VVd4ow-ZcX0

http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded

FUNDAMENTALS
    let is evaluated immediately
        all let-defined symbols are replaced with their corresponding values,
        then then expression is evaluated
    Functions represent unrealized computation: expressions not yet evaluated, or incomplete.
        functions exist to defer evaluation
        parameters are unbound symbols
        invoking a function binds values to those symbols

    if we put a quote in front of the expression, it will no longer be evaluated.
        '(red "nut1") ;;=> (red "nut1")
    quoting the expression turns it into a list, which we can manipulate with
    other s-expressions (code as data).
        (first '(red "nut1")) ;;=> red
        (last '(red "nut1")) ;;=> "nut1"
